<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>31 - Modified materials</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    html,
    body {
      overflow: hidden;
    }

    .webgl {
      position: fixed;
      top: 0;
      left: 0;
      outline: none;
    }
  </style>
</head>

<body>
  <!-- <div id="videoElem"></div> -->
  <canvas class="webgl"></canvas>
  <video id="video" autoplay loop webkit-playsinline style="display:none"></video>


  <script defer src="https://ga.jspm.io/npm:es-module-shims@1.6.2/dist/es-module-shims.js"></script>


  <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.147.0/build/three.module.js",
          "lil-gui": "https://unpkg.com/lil-gui@0.16.1/dist/lil-gui.esm.js",
          "OrbitControls": "https://unpkg.com/three@0.147.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  <script type="module">
    import * as THREE from 'three'
    import { OrbitControls } from "OrbitControls"
    import { GLTFLoader } from 'https://unpkg.com/three@0.147.0/examples/jsm/loaders/GLTFLoader.js'
    import { DRACOLoader } from 'https://unpkg.com/three@0.147.0/examples/jsm/loaders/DRACOLoader.js'
    import { CSS3DRenderer, CSS3DObject } from 'https://unpkg.com/three@0.147.0/examples/jsm/renderers/CSS3DRenderer.js'

    /**
     * Base
     */

    // Canvas
    const canvas = document.querySelector('canvas.webgl')

    // Scene
    const scene = new THREE.Scene()

    /**
     * Loaders
     */
    const textureLoader = new THREE.TextureLoader()
    const gltfLoader = new GLTFLoader()
    const cubeTextureLoader = new THREE.CubeTextureLoader()

    /**
     * Update all materials
     */
    const updateAllMaterials = () => {
      scene.traverse((child) => {
        if (child instanceof THREE.Mesh && child.material instanceof THREE.MeshStandardMaterial) {
          child.material.envMapIntensity = 1
          child.material.needsUpdate = true
          child.castShadow = true
          child.receiveShadow = true
        }
      })
    }

    /**
     * Environment map
     */
    const environmentMap = cubeTextureLoader.load([
      './textures/environmentMaps/0/px.jpg',
      './textures/environmentMaps/0/nx.jpg',
      './textures/environmentMaps/0/py.jpg',
      './textures/environmentMaps/0/ny.jpg',
      './textures/environmentMaps/0/pz.jpg',
      './textures/environmentMaps/0/nz.jpg'
    ])
    environmentMap.encoding = THREE.sRGBEncoding

    scene.background = environmentMap
    scene.environment = environmentMap

    /**
     * Material
     */

    // Textures
    const mapTexture = textureLoader.load('./models/LeePerrySmith/color.jpg')
    mapTexture.encoding = THREE.sRGBEncoding

    const normalTexture = textureLoader.load('./models/LeePerrySmith/normal.jpg')

    // Material
    const material = new THREE.MeshStandardMaterial({
      map: mapTexture,
      normalMap: normalTexture
    })

    const customUniforms = {
      uTime: { value: 0 }
    }

    const shadowMaterial = new THREE.MeshDepthMaterial({
      depthPacking: THREE.RGBADepthPacking
    })

    // hook onto material
    material.onBeforeCompile = (shader) => {
      shader.uniforms.uTime = customUniforms.uTime

      shader.vertexShader = shader.vertexShader.replace(
        '#include <common>',
        `
        #include <common>

        uniform float uTime;

        mat2 get2dRotateMatrix(float _angle) {
            return mat2(cos(_angle), - sin(_angle), sin(_angle), cos(_angle));
        }
        `
      )

      shader.vertexShader = shader.vertexShader.replace(
        '#include <beginnormal_vertex>',
        `
        #include <beginnormal_vertex>

        // make head move
        float angle = sin(position.y + uTime) * cos(position.y + uTime) * 0.4;
        mat2 rotateMatrix = get2dRotateMatrix(angle);

        objectNormal.xz = rotateMatrix * objectNormal.xz;
        `
      )


      shader.vertexShader = shader.vertexShader.replace(
        '#include <begin_vertex>',
        `
        #include <begin_vertex>

        transformed.xz = rotateMatrix * transformed.xz;
        `
      )
    }

    shadowMaterial.onBeforeCompile = (shader) => {
      shader.uniforms.uTime = customUniforms.uTime

      shader.vertexShader = shader.vertexShader.replace(
        '#include <common>',
        `
        #include <common>

        uniform float uTime;

        mat2 get2dRotateMatrix(float _angle)
        {
            return mat2(cos(_angle), - sin(_angle), sin(_angle), cos(_angle));
        }
        `
      )
      shader.vertexShader = shader.vertexShader.replace(
        '#include <begin_vertex>',
        `
        #include <begin_vertex>

        float angle = (position.y + uTime) * 0.9;
        mat2 rotateMatrix = get2dRotateMatrix(angle);

        transformed.xz = rotateMatrix * transformed.xz;
        `
      )
    }

    /**
     * Models
     */
    gltfLoader.load(
      './models/LeePerrySmith/LeePerrySmith.glb',
      (gltf) => {
        // Model
        const mesh = gltf.scene.children[0]
        mesh.rotation.y = Math.PI * 0.5
        mesh.material = material

        // tell mesh to use custom shadow material
        mesh.customDepthMaterial = shadowMaterial
        scene.add(mesh)

        // Update materials
        updateAllMaterials()
      }
    )

    // const plane = new THREE.Mesh(
    //   new THREE.PlaneGeometry(16 * 3, 9 * 3, 15),
    //   new THREE.MeshStandardMaterial()
    // )
    // plane.rotation.y = Math.PI * 0.5
    // plane.position.y = -5
    // plane.position.x = -25
    // scene.add(plane)

    const video = document.getElementById('video')
    video.src = "./video.mp4"
    video.load()

    const texture = new THREE.VideoTexture(video)
    texture.needsUpdate
    texture.minFilter = THREE.LinearFilter
    texture.magFilter = THREE.LinearFilter
    texture.format = THREE.RGBAFormat
    texture.crossOrigin = 'anonymous'

    const videoObj = new THREE.Mesh(
      new THREE.PlaneGeometry(16 * 7, 9 * 7),
      new THREE.MeshBasicMaterial({ map: texture })
    )
    videoObj.rotation.y = Math.PI * 0.5
    videoObj.position.y = -5
    videoObj.position.x = -90 + 0.01

    scene.add(videoObj)

    let playingVideo = false
    canvas.addEventListener("mousedown", (e) => {
      // console.log(e.button)
      // left click
      if (!playingVideo) {
        if (e.button === 0) {
          video.play()
        }
      }
    })

    // const width = '1280px'
    // const height = '720px'
    // const videoDiv = document.createElement('div')
    // videoDiv.style.width = width
    // videoDiv.style.height = height
    // videoDiv.style.backgroundColor = '#000'
    // videoDiv.style.pointerEvents = 'none'

    // const iframe = document.createElement('iframe')
    // iframe.style.width = width
    // iframe.style.height = height
    // iframe.style.border = '0px'
    // iframe.style.pointerEvents = 'auto'
    // iframe.src = 'https://www.youtube.com/embed/cLJrl0TOGNU?rel=0&autoplay=1&mute=1'
    // videoDiv.appendChild(iframe)

    // console.log(videoDiv)
    // console.log(iframe)
    // const videoObj = new CSS3DObject(videoDiv)
    // videoObj.rotation.y = Math.PI * 0.5
    // videoObj.position.y = -5
    // // videoObj.position.x = -25 + 0.01
    // scene.add(videoObj)

    // console.log(videoObj)
    // console.log(videoObj.position)


    /**
     * Lights
     */
    const directionalLight = new THREE.DirectionalLight('#ffffff', 3)
    directionalLight.castShadow = true
    directionalLight.shadow.mapSize.set(1024, 1024)
    directionalLight.shadow.camera.far = 15
    directionalLight.shadow.normalBias = 0.05
    directionalLight.position.set(0.25, 2, - 2.25)
    scene.add(directionalLight)

    const directionalLight2 = new THREE.DirectionalLight('#ffffff', 0.5)
    directionalLight2.castShadow = true
    directionalLight2.shadow.mapSize.set(1024, 1024)
    directionalLight2.shadow.camera.far = 15
    directionalLight2.shadow.normalBias = 0.05
    directionalLight2.position.x = 10
    directionalLight2.position.y = 2
    scene.add(directionalLight2)

    // const helper2 = new THREE.DirectionalLightHelper(directionalLight2, 3)
    // scene.add(helper2)

    /**
     * Sizes
     */
    const sizes = {
      width: window.innerWidth,
      height: window.innerHeight
    }

    window.addEventListener('resize', () => {
      // Update sizes
      sizes.width = window.innerWidth
      sizes.height = window.innerHeight

      // Update camera
      camera.aspect = sizes.width / sizes.height
      camera.updateProjectionMatrix()

      // Update renderer
      renderer.setSize(sizes.width, sizes.height)
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    })

    /**
     * Camera
     */
    // Base camera
    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 1000)
    camera.position.set(15, 7, 0)
    scene.add(camera)

    // Controls
    const controls = new OrbitControls(camera, canvas)
    controls.enableDamping = true

    /**
     * Renderers
     */
    const renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      antialias: true
    })
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFShadowMap
    renderer.physicallyCorrectLights = true
    renderer.outputEncoding = THREE.sRGBEncoding
    renderer.toneMapping = THREE.ACESFilmicToneMapping
    renderer.toneMappingExposure = 1
    renderer.setSize(sizes.width, sizes.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))


    // const renderer2 = new CSS3DRenderer()
    // renderer2.domElement.style.position = 'absolute'
    // renderer2.domElement.style.top = 0
    // document.querySelector('#videoElem').appendChild(renderer2.domElement)

    /**
     * Animate
     */
    const clock = new THREE.Clock()

    const tick = () => {
      const elapsedTime = clock.getElapsedTime()

      customUniforms.uTime.value = elapsedTime

      // Update controls
      controls.update()

      // Render
      renderer.render(scene, camera)

      // Call tick again on the next frame
      window.requestAnimationFrame(tick)
    }

    tick()
  </script>
</body>

</html>